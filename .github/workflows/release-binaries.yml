
# Note: it is not safe to run this workflow multiple times concurrently.

name: 'Release'

on:
  workflow_dispatch:
    inputs:
      bump:
        type: choice
        description: Which semver number to bump
        options:
          - major
          - minor
          - patch
        default: minor
        required: true

jobs:
  next_version:
    name: Next version
    runs-on: ubuntu-latest
    outputs:
      previous_version: ${{ steps.prev_ver.outputs.previous_version }}
      next_version: ${{ steps.next_ver.outputs.next_version }}
      bump_draft_ref: ${{ steps.commit.outputs.bump_draft_ref }}
      branch: ${{ steps.commit.outputs.branch }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.ACCESS_TOKEN }}
      - name: Get current version
        id: prev_ver
        run: |
          set -x
          PREV_VER="$({ printf 'v0.0.0\n'; git tag --list; } | grep -E '^v[0-9]' | cut -c2- | sort --reverse --version-sort --field-separator=. | head -n1)"
          echo "current (soon to be previous) version: v$PREV_VER"
          echo ::set-output name=previous_version::"$PREV_VER"
      - name: Get next version
        id: next_ver
        run: |
          set -x
          echo "going to bump ${{ github.event.inputs.bump }} of v${{ steps.prev_ver.outputs.previous_version }}"
          NEXT_VER="$(curl -f https://next.tryin.top/${{ github.event.inputs.bump }}/${{ steps.prev_ver.outputs.previous_version }})"
          echo "next (soon to be current) version: v$NEXT_VER"
          echo ::set-output name=next_version::"$NEXT_VER"
      - name: Bump Cargo.toml
        run: |
          sed -Ei 's/^version\s+=\s+"[^"]*"/version = "${{ steps.next_ver.outputs.next_version }}"/' Cargo.toml
      - name: Update readme
        run: |
          set -x
          cargo build
          python3 - <<EOF
          import re
          from subprocess import check_output
          with open('README.md', 'r') as f:
              readme = f.read()
          cli_help_re = '\`\`\`cli_help.*?\`\`\`'
          parts = re.compile(cli_help_re, re.DOTALL).split(readme)
          if len(parts) > 1:
              print('updating readme')
              cli_help = check_output(['cargo', 'run', '--', '--help']).decode('utf-8')
              cli_help = '\`\`\`cli_help\n{}\n\`\`\`'.format(cli_help.strip())
              with open('README.md', 'w') as f:
                  f.write(cli_help.join(parts))
          else:
              print('not updating readme, no cli_help section')
          EOF
          cat README.md
      - name: Commit on branch
        id: commit
        run: |
          set -x
          MSG1="Bumped ${{ github.event.inputs.bump }} to v${{ steps.next_ver.outputs.next_version }} from v${{ steps.prev_ver.outputs.previous_version }}."
          MSG2="Auto-bump by Github Actions workflow '${{ github.workflow }}' job '${{ github.job }}' run '${{ github.run_id }}' triggered by '${{ github.event_name }}/${{ github.event.action }}'."
          echo "$MSG1\n$MSG2"
          git config user.name 'Mark release bot'
          git config user.email 'mverleg.noreply@gmail.com'
          git branch -D release-workflow || true
          git checkout -b release-workflow
          git add :/ --all
          echo 'Create special branch for now, to keep this commit out of main'
          echo ::set-output name=branch::"$(git rev-parse --abbrev-ref HEAD)"
          git commit --allow-empty -m "Version ${{ steps.next_ver.outputs.next_version }}" -m "$MSG1" -m "$MSG2"
          git push --force origin release-workflow
          echo ::set-output name=bump_draft_ref::"$(git rev-parse HEAD)"

  create_matrix:
    name: Make matrix
    needs: next_version
    runs-on: ubuntu-latest
    outputs:
      bin_targets: ${{ steps.generate_matrix.outputs.bin_targets }}
      do_artifact: ${{ steps.conf.outputs.do_artifact }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          ref: ${{ needs.next_version.outputs.bump_draft_ref }}
      - name: Check conditions
        id: conf
        run: |
          set -x
          echo ::set-output name=do_artifact::1;
          if [ "$(jq .release.artifact -r ci-conf.json)" = false ] || [ "$(jq .release.artifact -r ci-conf.json)" = null ]; then echo 'skipping because no release artifact config'; echo ::set-output name=artifact::0; fi
          if [ "$(jq .release.artifact.targets -r ci-conf.json)" = false ]; then echo 'skipping because no targets'; echo ::set-output name=artifact::0; fi
          if [ "$(jq .release.artifact.bins -r ci-conf.json)" = false ]; then echo 'skipping because no binaries'; echo ::set-output name=artifact::0; fi
      - name: Generate matrix
        id: generate_matrix
        if: steps.conf.outputs.do_artifact == 1
        run: |
          set -x
          version_name="$(printf "v${{ needs.next_version.outputs.next_version }}" | sed 's/\./_/g')"
          mat="$(jq .release.artifact -r ci-conf.json |\
              jq '.targets[] + (.bins[] | {"bin": .})' |\
              jq ". + {asset_name: (.bin + \"-\" + \"$version_name\" + \"-\" + .target)}" |\
              jq -sc '{"include":.}')"
          echo $mat | jq
          echo ::set-output name=bin_targets::"$mat"

  matrix_compile:
    name: Build binaries
    needs: [next_version, create_matrix]
    runs-on: ubuntu-latest
    if: needs.create_matrix.outputs.do_artifact == 1
    strategy:
      matrix: ${{ fromJson(needs.create_matrix.outputs.bin_targets) }}
    steps:
      - name: Log matrix
        run: |
          echo bin=${{ matrix.bin }}
          echo target=${{ matrix.target }}
          echo asset_name=${{ matrix.asset_name }}
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          ref: ${{ needs.next_version.outputs.bump_draft_ref }}
      - name: Build project
        run: |
          cat ./ci/release.Dockerfile
          set -x
          docker build --build-arg BIN="${{ matrix.bin }}" --build-arg TARGET="${{ matrix.target }}" -t release-image -f ./ci/release.Dockerfile .
          id=$(docker create release-image)
          docker cp "$id:/${{ matrix.bin }}" "${{ matrix.asset_name }}"
          if ! [ -f "${{ matrix.asset_name }}" ]; then exit 1; fi
      - name: Store binary
        uses: actions/upload-artifact@master
        with:
          name: ${{ matrix.asset_name }}
          path: ${{ matrix.asset_name }}

  create_release:
    name: Create Github release
    # include `matrix_compile` in neees to prevent creating release if build fails
    needs: [next_version, matrix_compile]
    runs-on: ubuntu-latest
    outputs:
      bump_main_ref: ${{ steps.commit.outputs.bump_main_ref }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          ref: ${{ needs.next_version.outputs.branch }}
      - name: Git tag
        id: tag
        run: |
          echo "Move the bump commit to the main branch and tag it"
          set -x
          git branch --show-current
          git log -n3
          git config user.name 'Mark release bot'
          git config user.email 'mverleg.noreply@gmail.com'
          git cherry-pick --keep-redundant-commits "${{ needs.next_version.outputs.bump_draft_ref }}"
          git branch -D release-workflow || true
          cmt_mgs_pth="$(mktemp)"
          git log --format=%B -n 1 > "$cmt_mgs_pth"
          git tag -a v${{ needs.next_version.outputs.next_version }} -F "$cmt_mgs_pth"
          git log -n3
          git push --tags
          git push origin --delete release-workflow
          echo ::set-output name=bump_main_ref::"$(git rev-parse HEAD)"
      - name: release
        uses: actions/create-release@v1
        id: create_release
        with:
          draft: false
          prerelease: false
          release_name: v${{ needs.next_version.outputs.next_version }}
          tag_name: v${{ needs.next_version.outputs.next_version }}
          body: "Bumped ${{ github.event.inputs.bump }} version from ${{ needs.next_version.outputs.previous_version }} to ${{ needs.next_version.outputs.next_version }}."
        env:
          GITHUB_TOKEN: ${{ github.token }}
      - name: Upload readme to release
        uses: svenstaro/upload-release-action@v1-release
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: README.md
          asset_name: README.md
          tag: v${{ needs.next_version.outputs.next_version }}
      - name: Create metadata
        run: |
          set -ux
          printf '%s\n%s\n%s\n' \
            "${{ needs.next_version.outputs.next_version }}" \
            "${{ steps.tag.outputs.bump_main_ref }}" \
            "$(date -u +%s)" \
              > INFO
      - name: Upload metadata to release
        uses: svenstaro/upload-release-action@v1-release
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: INFO
          asset_name: INFO
          tag: v${{ needs.next_version.outputs.next_version }}

  matrix_attach:
    name: Attach binaries
    needs: [next_version, create_matrix, create_release, matrix_compile]
    runs-on: ubuntu-latest
    if: needs.create_matrix.outputs.do_artifact == 1
    strategy:
      matrix: ${{ fromJson(needs.create_matrix.outputs.bin_targets) }}
    steps:
      - name: Log matrix
        run: |
          echo bin=${{ matrix.bin }}
          echo target=${{ matrix.target }}
          echo asset_name=${{ matrix.asset_name }}
      - name: Retrieve binary
        uses: actions/download-artifact@master
        with:
          name: ${{ matrix.asset_name }}
          path: ${{ matrix.asset_name }}
      - name: Debug
        run: |
          #TODO @mark: 
          ls -als
          echo "matrix.asset_name: ${{ matrix.asset_name }}"
          echo "needs.next_version.outputs.next_version: v${{ needs.next_version.outputs.next_version }}"
      - name: Upload binary to release
        uses: svenstaro/upload-release-action@v1-release
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: ${{ matrix.asset_name }}
          asset_name: ${{ matrix.asset_name }}
          tag: v${{ needs.next_version.outputs.next_version }}
